use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use crate::transaction::InnerTransaction;
pub mod aa;

/// Base execution options for all transactions
/// All specific execution options share this
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct BaseExecutionOptions {
    pub chain_id: u64,
    #[serde(default = "default_idempotency_key")]
    pub idempotency_key: String,
}

fn default_idempotency_key() -> String {
    uuid::Uuid::new_v4().to_string()
}

/// All supported specific execution options are contained here
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type")]
pub enum SpecificExecutionOptions {
    /// # ERC-4337 Execution Options
    /// This struct allows flexible configuration of ERC-4337 execution options,
    /// with intelligent defaults and inferences based on provided values.
    ///
    /// ## Field Inference
    /// When fields are omitted, the system uses the following inference rules:
    ///
    /// 1. **Version Inference**:
    ///    - If `entrypointVersion` is provided, it's used directly
    ///    - Otherwise, tries to infer from `entrypointAddress` (if provided)
    ///    - If that fails, tries to infer from `factoryAddress` (if provided)
    ///    - Defaults to version 0.7 if no inference is possible
    ///
    /// 2. **Entrypoint Address Inference**:
    ///    - If provided explicitly, it's used as-is
    ///    - Otherwise, uses the default address corresponding to the inferred version:
    ///      - V0.6: 0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789
    ///      - V0.7: 0x0576a174D229E3cFA37253523E645A78A0C91B57
    ///
    /// 3. **Factory Address Inference**:
    ///    - If provided explicitly, it's used as-is
    ///    - Otherwise, uses the default factory corresponding to the inferred version:
    ///      - V0.6: [DEFAULT_FACTORY_ADDRESS_V0_6]
    ///      - V0.7: [DEFAULT_FACTORY_ADDRESS_V0_7]
    ///
    /// 4. **Account Salt**:
    ///    - If provided explicitly, it's used as-is
    ///    - Otherwise, defaults to "0x" (commonly used as the defauult "null" salt for smart accounts)
    ///
    /// 5. **Smart Account Address**:
    ///    - If provided explicitly, it's used as-is
    ///    - Otherwise, it's read from the smart account factory
    ///
    /// All optional fields can be omitted for a minimal configuration using version 0.7 defaults.
    ERC4337(aa::Erc4337ExecutionOptions),
}

/// This is the exposed API for execution options
/// Base and specific execution options are both flattened together
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct ExecutionOptions {
    #[serde(flatten)]
    pub base: BaseExecutionOptions,
    #[serde(flatten)]
    pub specific: SpecificExecutionOptions,
}

#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema)]
pub struct WebhookOptions {
    pub url: String,
    pub secret: Option<String>,
}

/// Incoming transaction request, parsed into InnerTransaction
/// Exposed API will have varying `params` but will all parse into InnerTransaction before execution
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct SendTransactionRequest {
    pub execution_options: ExecutionOptions,
    pub params: Vec<InnerTransaction>,
    pub webhook_options: Option<Vec<WebhookOptions>>,
}

/// # QueuedTransaction
/// Response for any request that queues one or more transactions
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct QueuedTransaction {
    /// The idempotency key this transaction was queued with
    /// Either autogenerated UUID or provided by the user
    /// Multiple queued transactions can have the same idempotency key
    /// A "blockchain transaction" is uniquely identified by the idempotency key + batchIndex
    pub id: String,

    /// When multiple transactions are sent together via an execution mode that doesn't support atomic batching,
    /// each transaction will have a unique batchIndex but the same id (idempotency key)
    /// This maintains the relationship between different atomically sent blockchain transactions that were queued together
    pub batch_index: u64,

    /// The fully resolved execution options for this transaction, derived from the resolution of user specific execution options
    /// Difference in naming is to prevent confusion when response executionParams contain different values than the request executionOptions
    pub execution_params: ExecutionOptions,

    /// This is the actual encoded inner transaction data that will be sent to the blockchain.
    /// For non-atomic transactions, this will be a single transaction
    /// For atomic transactions, this will be a list of transactions, because they were atomically sent together
    pub transaction_params: Vec<InnerTransaction>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct QueuedTransactionsResponse {
    pub transactions: Vec<QueuedTransaction>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutorType {
    #[serde(rename = "ERC4337")]
    Erc4337,
}

impl ExecutionOptions {
    pub fn executor_type(&self) -> ExecutorType {
        match &self.specific {
            SpecificExecutionOptions::ERC4337(_) => ExecutorType::Erc4337,
        }
    }

    pub fn chain_id(&self) -> u64 {
        self.base.chain_id
    }

    pub fn transaction_id(&self) -> &str {
        &self.base.idempotency_key
    }
}
